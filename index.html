<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linel - Logic & Puzzle</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Animated Background -->
    <div class="background">
        <div class="grid-bg"></div>
        <div class="floating-elements">
            <div class="floating-circle"></div>
            <div class="floating-square"></div>
            <div class="floating-triangle"></div>
        </div>
    </div>

    <!-- Main Header -->
    <header class="hero">
        <div class="hero-content">
            <div class="logo">
                <div class="logo-icon">
                    <svg viewBox="0 0 100 100" width="60" height="60">
                        <defs>
                            <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#00f5ff"/>
                                <stop offset="100%" style="stop-color:#8a2be2"/>
                            </linearGradient>
                        </defs>
                        <circle cx="20" cy="20" r="8" fill="url(#logoGradient)"/>
                        <circle cx="80" cy="80" r="8" fill="url(#logoGradient)"/>
                        <path d="M20 20 Q50 10 80 80" stroke="url(#logoGradient)" stroke-width="4" fill="none"/>
                    </svg>
                </div>
                <span class="logo-text">LINEL</span>
            </div>
            <h1 class="main-title">
                <span class="title-line">The Ultimate</span>
                <span class="title-line highlight">Maze Navigation</span>
                <span class="title-line">Challenge</span>
            </h1>
            <p class="hero-subtitle">
                Navigate through randomly generated mazes. Click to start, follow with your mouse.
                <br>
                <span class="subtitle-accent">Dynamic pathfinding puzzles with customizable rules</span>
            </p>
            <button class="cta-button" onclick="startGame()">
                <span class="button-text">Start Puzzle</span>
                <div class="button-glow"></div>
            </button>
        </div>
    </header>

    <!-- Game Container -->
    <main class="game-section" id="gameSection" style="display: none;">
        <div class="game-header">
            <div class="game-info">
                <div class="level-indicator">
                    <span class="level-label">Level</span>
                    <span class="level-number" id="levelNumber">01</span>
                </div>
                <div class="score-display">
                    <span class="score-label">Score</span>
                    <span class="score-number" id="scoreNumber">0</span>
                </div>
            </div>
            <button class="menu-button" onclick="showMenu()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>
        </div>

        <div class="game-container">
            <div class="canvas-wrapper">
                <canvas id="puzzleCanvas" width="500" height="500"></canvas>
                <div class="canvas-overlay">
                    <div class="completion-animation" id="completionAnimation">
                        <div class="success-icon">‚úì</div>
                        <div class="success-text">Puzzle Solved!</div>
                        <div class="success-particles"></div>
                    </div>
                </div>
            </div>
            
            <div class="game-controls">
                <div class="control-group">
                    <button class="control-btn secondary" id="clearBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                        </svg>
                        Clear Path
                    </button>
                    <button class="control-btn primary" id="newPuzzleBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 4v6h6"></path>
                            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                        </svg>
                        New Maze
                    </button>
                    <button class="control-btn accent" id="hintBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                            <line x1="12" y1="17" x2="12.01" y2="17"></line>
                        </svg>
                        Show Solution
                    </button>
                </div>
                
                <!-- Maze Size Selector -->
                <div class="maze-size-controls">
                    <label for="mazeSizeSelect" class="size-label">Maze Size:</label>
                    <select id="mazeSizeSelect" class="size-select">
                        <option value="7">Small (7√ó7)</option>
                        <option value="11" selected>Medium (11√ó11)</option>
                        <option value="15">Large (15√ó15)</option>
                        <option value="19">X-Large (19√ó19)</option>
                        <option value="23">XXL (23√ó23)</option>
                    </select>
                </div>
            </div>
            
            <div class="status-panel" id="status">
                <div class="status-content">
                    <div class="status-icon">üß≠</div>
                    <div class="status-text">Click the green circle to start navigating the maze!</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
    </main>

    <!-- Features Section -->
    <section class="features" id="featuresSection">
        <div class="features-container">
            <h2 class="section-title">Game Features</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <div class="feature-icon">üß©</div>
                    <h3>Progressive Mazes</h3>
                    <p>Navigate through increasingly complex randomly generated mazes with evolving rules</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üé®</div>
                    <h3>Smart Path Drawing</h3>
                    <p>Lines automatically follow maze constraints with full cell coverage</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üì±</div>
                    <h3>Cross-Platform</h3>
                    <p>Play seamlessly on desktop, tablet, or mobile with responsive design</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">‚öôÔ∏è</div>
                    <h3>Customizable Rules</h3>
                    <p>Extensible rule system for adding new puzzle elements and mechanics</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Instructions Section -->
    <section class="instructions">
        <div class="instructions-container">
            <h2 class="section-title">How to Play</h2>
            <div class="instruction-steps">
                <div class="step">
                    <div class="step-number">1</div>
                    <h3>Click to Start</h3>
                    <p>Click on the green starting circle to begin drawing</p>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <h3>Navigate the Maze</h3>
                    <p>Move your mouse through the maze - the line follows automatically</p>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <h3>Reach the Goal</h3>
                    <p>Navigate to the red square - all rules must pass to win!</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 Linel. Inspired by Jonathan Blow's The Witness.</p>
            <div class="footer-links">
                <a href="#" onclick="showAbout()">About</a>
                <a href="https://github.com/yourusername/linel-puzzle-game" target="_blank">GitHub</a>
                <a href="#" onclick="showContact()">Contact</a>
            </div>
        </div>
    </footer>

    <!-- Load JavaScript modules in correct order -->
    <script src="js/utils.js"></script>
    <script src="js/gridGenerator.js"></script>
    <script src="js/mazeGenerator.js"></script>
    <script src="js/rulesEngine.js"></script>
    <script src="js/renderer.js"></script>
    <script src="js/inputHandler.js"></script>
    <script src="js/game.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Inter', sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        #gameCanvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            background: rgba(26, 26, 46, 0.9);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(45deg, #00f5ff, #8a2be2);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        .info {
            margin-top: 20px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }
        
        #status {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .settings {
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }
        
        select {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 10px;
            cursor: pointer;
        }
        
        select option {
            background: #333;
        }
        
        label {
            font-weight: 500;
        }
    </style>
</head>
<body>
    <h1>üß© Linel - Maze Navigator</h1>
    
    <div class="settings">
        <label>Maze Size: 
            <select id="mazeSize">
                <option value="7">7x7</option>
                <option value="11" selected>11x11</option>
                <option value="15">15x15</option>
                <option value="19">19x19</option>
            </select>
        </label>
        <label>Cell Size: 
            <select id="cellSize">
                <option value="20">Small (20px)</option>
                <option value="30" selected>Medium (30px)</option>
                <option value="40">Large (40px)</option>
            </select>
        </label>
        <label>Resolution: 
            <select id="resolution">
                <option value="1">Low (1x)</option>
                <option value="3">Medium (3x)</option>
                <option value="5" selected>High (5x)</option>
                <option value="10">Ultra (10x)</option>
            </select>
        </label>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="controls">
            <button onclick="game.clearPath()">Clear Path</button>
            <button onclick="game.generateNewMaze()">New Maze</button>
            <button onclick="game.showSolution()">Show Solution</button>
        </div>
        
        <div class="info">
            <div id="status">Click the green circle to start!</div>
            <div id="debug"></div>
        </div>
    </div>

    <script>
// ===========================
// COMPLETE GAME IMPLEMENTATION
// ===========================

class MazeGame {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        // Maze configuration
        this.mazeSize = 11;  // Visual grid size (what user sees)
        this.cellSize = 30;  // Pixels per visual cell
        this.resolution = 5; // Movement resolution per visual cell
        
        // Calculate actual dimensions
        this.actualGridSize = this.mazeSize * this.resolution;
        this.pixelPerMovement = this.cellSize / this.resolution;
        
        // Game state
        this.maze = null;
        this.startPos = null;
        this.endPos = null;
        this.currentPath = [];
        this.isDrawing = false;
        this.solution = null;
        
        // Mouse tracking
        this.mousePos = { x: 0, y: 0 };
        this.lastValidPos = null;
        
        this.init();
    }
    
    init() {
        this.updateCanvasSize();
        this.generateNewMaze();
        this.setupEventListeners();
        this.render();
    }
    
    updateCanvasSize() {
        this.canvas.width = this.mazeSize * this.cellSize;
        this.canvas.height = this.mazeSize * this.cellSize;
    }
    
    setupEventListeners() {
        // Remove old listeners
        this.canvas.replaceWith(this.canvas.cloneNode());
        this.canvas = document.getElementById(this.canvas.id);
        this.ctx = this.canvas.getContext('2d');
        
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('mouseleave', (e) => this.handleMouseLeave(e));
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
    }
    
    generateNewMaze() {
        // Create a simple maze (odd dimensions work better)
        const size = this.mazeSize;
        this.maze = Array(size).fill().map(() => Array(size).fill(1)); // 1 = wall
        
        // Generate maze using recursive backtracking
        const stack = [];
        const visited = Array(size).fill().map(() => Array(size).fill(false));
        
        // Start from (1,1)
        let current = { x: 1, y: 1 };
        this.maze[1][1] = 0; // 0 = path
        visited[1][1] = true;
        stack.push(current);
        
        while (stack.length > 0) {
            const neighbors = this.getUnvisitedNeighbors(current, visited);
            
            if (neighbors.length > 0) {
                const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                
                // Remove wall between current and next
                const wallX = current.x + (next.x - current.x) / 2;
                const wallY = current.y + (next.y - current.y) / 2;
                this.maze[wallY][wallX] = 0;
                this.maze[next.y][next.x] = 0;
                
                visited[next.y][next.x] = true;
                stack.push(next);
                current = next;
            } else {
                current = stack.pop();
            }
        }
        
        // Place start and end points
        this.placeStartAndEnd();
        
        // Find solution
        this.solution = this.findSolution();
        
        // Clear current path
        this.currentPath = [];
        this.isDrawing = false;
        
        this.updateStatus("Click the green circle to start!");
    }
    
    getUnvisitedNeighbors(pos, visited) {
        const neighbors = [];
        const directions = [
            { x: 0, y: -2 }, // Up
            { x: 2, y: 0 },  // Right
            { x: 0, y: 2 },  // Down
            { x: -2, y: 0 }  // Left
        ];
        
        for (const dir of directions) {
            const newX = pos.x + dir.x;
            const newY = pos.y + dir.y;
            
            if (newX > 0 && newX < this.mazeSize - 1 && 
                newY > 0 && newY < this.mazeSize - 1 && 
                !visited[newY][newX]) {
                neighbors.push({ x: newX, y: newY });
            }
        }
        
        return neighbors;
    }
    
    placeStartAndEnd() {
        // Find all path cells
        const pathCells = [];
        for (let y = 0; y < this.mazeSize; y++) {
            for (let x = 0; x < this.mazeSize; x++) {
                if (this.maze[y][x] === 0) {
                    pathCells.push({ x, y });
                }
            }
        }
        
        // Place start at first available path
        this.startPos = pathCells[0];
        
        // Place end at farthest point
        let maxDist = 0;
        this.endPos = pathCells[0];
        
        for (const cell of pathCells) {
            const dist = Math.abs(cell.x - this.startPos.x) + Math.abs(cell.y - this.startPos.y);
            if (dist > maxDist) {
                maxDist = dist;
                this.endPos = cell;
            }
        }
    }
    
    findSolution() {
        // Simple BFS to find solution
        const queue = [{ pos: this.startPos, path: [this.startPos] }];
        const visited = new Set();
        visited.add(`${this.startPos.x},${this.startPos.y}`);
        
        while (queue.length > 0) {
            const { pos, path } = queue.shift();
            
            if (pos.x === this.endPos.x && pos.y === this.endPos.y) {
                return path;
            }
            
            const directions = [
                { x: 0, y: -1 }, { x: 1, y: 0 }, 
                { x: 0, y: 1 }, { x: -1, y: 0 }
            ];
            
            for (const dir of directions) {
                const newX = pos.x + dir.x;
                const newY = pos.y + dir.y;
                const key = `${newX},${newY}`;
                
                if (newX >= 0 && newX < this.mazeSize && 
                    newY >= 0 && newY < this.mazeSize &&
                    this.maze[newY][newX] === 0 && 
                    !visited.has(key)) {
                    
                    visited.add(key);
                    queue.push({
                        pos: { x: newX, y: newY },
                        path: [...path, { x: newX, y: newY }]
                    });
                }
            }
        }
        
        return null;
    }
    
    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Convert to visual grid coordinates
        const gridX = Math.floor(x / this.cellSize);
        const gridY = Math.floor(y / this.cellSize);
        
        // Check if clicking on start
        if (gridX === this.startPos.x && gridY === this.startPos.y) {
            this.isDrawing = true;
            this.currentPath = [{
                x: this.startPos.x * this.resolution + Math.floor(this.resolution / 2),
                y: this.startPos.y * this.resolution + Math.floor(this.resolution / 2)
            }];
            this.lastValidPos = { ...this.currentPath[0] };
            this.updateStatus("Draw a path to the red square!");
        }
    }
    
    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos.x = e.clientX - rect.left;
        this.mousePos.y = e.clientY - rect.top;
        
        if (this.isDrawing && this.currentPath.length > 0) {
            // Convert mouse position to high-resolution grid
            const highResX = Math.floor(this.mousePos.x / this.pixelPerMovement);
            const highResY = Math.floor(this.mousePos.y / this.pixelPerMovement);
            
            // Get the last position in path
            const lastPos = this.currentPath[this.currentPath.length - 1];
            
            // Try to path from last position to mouse position
            this.extendPath(lastPos, { x: highResX, y: highResY });
        }
        
        this.render();
    }
    
    extendPath(from, to) {
        // Simple pathfinding from current position to target
        const dx = Math.sign(to.x - from.x);
        const dy = Math.sign(to.y - from.y);
        
        let current = { ...from };
        let steps = 0;
        const maxSteps = this.resolution * 2; // Limit steps per frame
        
        while ((current.x !== to.x || current.y !== to.y) && steps < maxSteps) {
            let nextX = current.x;
            let nextY = current.y;
            
            // Try to move towards target
            if (current.x !== to.x) nextX += dx;
            if (current.y !== to.y) nextY += dy;
            
            // Check if valid move
            if (this.isValidHighResPosition(nextX, nextY)) {
                // Check if we're backtracking
                const existingIndex = this.currentPath.findIndex(p => 
                    p.x === nextX && p.y === nextY
                );
                
                if (existingIndex !== -1) {
                    // Backtrack to this position
                    this.currentPath = this.currentPath.slice(0, existingIndex + 1);
                } else {
                    // Add new position
                    this.currentPath.push({ x: nextX, y: nextY });
                }
                
                current = { x: nextX, y: nextY };
                
                // Check if reached end
                const visualX = Math.floor(nextX / this.resolution);
                const visualY = Math.floor(nextY / this.resolution);
                
                if (visualX === this.endPos.x && visualY === this.endPos.y) {
                    this.completeMaze();
                    return;
                }
            } else {
                // Try alternative moves
                if (current.x !== to.x && this.isValidHighResPosition(current.x + dx, current.y)) {
                    current.x += dx;
                    this.currentPath.push({ x: current.x, y: current.y });
                } else if (current.y !== to.y && this.isValidHighResPosition(current.x, current.y + dy)) {
                    current.y += dy;
                    this.currentPath.push({ x: current.x, y: current.y });
                } else {
                    break; // Can't move
                }
            }
            
            steps++;
        }
    }
    
    isValidHighResPosition(highResX, highResY) {
        // Convert to visual grid
        const visualX = Math.floor(highResX / this.resolution);
        const visualY = Math.floor(highResY / this.resolution);
        
        // Check bounds
        if (visualX < 0 || visualX >= this.mazeSize || 
            visualY < 0 || visualY >= this.mazeSize) {
            return false;
        }
        
        // Check if it's a path
        return this.maze[visualY][visualX] === 0;
    }
    
    handleMouseUp(e) {
        // Keep drawing active until maze is complete or user clicks again
    }
    
    handleMouseLeave(e) {
        // Optional: pause drawing when mouse leaves
    }
    
    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        this.handleMouseDown(mouseEvent);
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        this.handleMouseMove(mouseEvent);
    }
    
    handleTouchEnd(e) {
        e.preventDefault();
        this.handleMouseUp(e);
    }
    
    completeMaze() {
        this.isDrawing = false;
        this.updateStatus("üéâ Maze Complete! Well done!");
        
        // Celebration animation
        setTimeout(() => {
            this.generateNewMaze();
            this.render();
        }, 2000);
    }
    
    clearPath() {
        this.currentPath = [];
        this.isDrawing = false;
        this.updateStatus("Path cleared. Click the green circle to start!");
        this.render();
    }
    
    showSolution() {
        if (this.solution) {
            // Convert solution to high-res path
            this.currentPath = [];
            for (const pos of this.solution) {
                const centerX = pos.x * this.resolution + Math.floor(this.resolution / 2);
                const centerY = pos.y * this.resolution + Math.floor(this.resolution / 2);
                this.currentPath.push({ x: centerX, y: centerY });
            }
            this.isDrawing = false;
            this.updateStatus("Solution shown!");
            this.render();
        }
    }
    
    render() {
        const ctx = this.ctx;
        
        // Clear canvas
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw maze
        for (let y = 0; y < this.mazeSize; y++) {
            for (let x = 0; x < this.mazeSize; x++) {
                const pixelX = x * this.cellSize;
                const pixelY = y * this.cellSize;
                
                if (this.maze[y][x] === 1) {
                    // Wall
                    ctx.fillStyle = '#0f0f23';
                    ctx.fillRect(pixelX, pixelY, this.cellSize, this.cellSize);
                } else {
                    // Path
                    ctx.fillStyle = '#2a2a4e';
                    ctx.fillRect(pixelX, pixelY, this.cellSize, this.cellSize);
                }
                
                // Grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.strokeRect(pixelX, pixelY, this.cellSize, this.cellSize);
            }
        }
        
        // Draw start point
        ctx.fillStyle = '#4caf50';
        ctx.beginPath();
        ctx.arc(
            this.startPos.x * this.cellSize + this.cellSize / 2,
            this.startPos.y * this.cellSize + this.cellSize / 2,
            this.cellSize / 3,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw end point
        ctx.fillStyle = '#f44336';
        ctx.fillRect(
            this.endPos.x * this.cellSize + this.cellSize / 4,
            this.endPos.y * this.cellSize + this.cellSize / 4,
            this.cellSize / 2,
            this.cellSize / 2
        );
        
        // Draw current path
        if (this.currentPath.length > 0) {
            ctx.strokeStyle = '#00f5ff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            for (let i = 0; i < this.currentPath.length; i++) {
                const point = this.currentPath[i];
                const pixelX = point.x * this.pixelPerMovement;
                const pixelY = point.y * this.pixelPerMovement;
                
                if (i === 0) {
                    ctx.moveTo(pixelX, pixelY);
                } else {
                    ctx.lineTo(pixelX, pixelY);
                }
            }
            ctx.stroke();
            
            // Draw path end point
            if (this.currentPath.length > 0) {
                const lastPoint = this.currentPath[this.currentPath.length - 1];
                ctx.fillStyle = '#00f5ff';
                ctx.beginPath();
                ctx.arc(
                    lastPoint.x * this.pixelPerMovement,
                    lastPoint.y * this.pixelPerMovement,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            }
        }
        
        // Draw mouse indicator when drawing
        if (this.isDrawing) {
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.mousePos.x, this.mousePos.y, 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Update debug info
        this.updateDebug();
    }
    
    updateStatus(message) {
        document.getElementById('status').textContent = message;
    }
    
    updateDebug() {
        const debug = document.getElementById('debug');
        debug.innerHTML = `
            Visual Grid: ${this.mazeSize}√ó${this.mazeSize} | 
            Cell Size: ${this.cellSize}px | 
            Resolution: ${this.resolution}√ó${this.resolution} per cell | 
            Path Length: ${this.currentPath.length} points
        `;
    }
    
    updateSettings(mazeSize, cellSize, resolution) {
        this.mazeSize = mazeSize;
        this.cellSize = cellSize;
        this.resolution = resolution;
        
        this.actualGridSize = this.mazeSize * this.resolution;
        this.pixelPerMovement = this.cellSize / this.resolution;
        
        this.updateCanvasSize();
        this.generateNewMaze();
        this.setupEventListeners();
        this.render();
    }
}

// Initialize game
let game;

window.onload = () => {
    game = new MazeGame('gameCanvas');
    
    // Setup settings listeners
    document.getElementById('mazeSize').addEventListener('change', updateSettings);
    document.getElementById('cellSize').addEventListener('change', updateSettings);
    document.getElementById('resolution').addEventListener('change', updateSettings);
};

function updateSettings() {
    const mazeSize = parseInt(document.getElementById('mazeSize').value);
    const cellSize = parseInt(document.getElementById('cellSize').value);
    const resolution = parseInt(document.getElementById('resolution').value);
    
    game.updateSettings(mazeSize, cellSize, resolution);
}
    </script>
</body>
</html>